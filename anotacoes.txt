-- Criar projeto
ng new <project-name>

-- inicia o progeto
ng serve

-- cria um componente
ng g c <NomeDoComponente>

-- adiciona uma dependecia ao angular
ng add @angular/material

constructor -> chamado quando o componente é criado
ngOnInit -> chamado logo apos o componente ser criado e carregado
ngOnDestroy -> chamado quando um componente é destruído
ngAfterViewInit -> chamado após todas as referencias de variaveis estarem prontas

-- String interpolation - transforma um dado em string
{{ <var> }} 

-- property-binding - exibe o conteudo de uma variavel na tela
[color]="variavel"

-- envia dados para a classe
(input) = "inputName = $event.target.value"
(click) = "executarAlgo($event)"

Two Way DataBinding - a alteracao é feita em tela e refletida automaticamente na classe
<input [(ngModel)]="name1" name="qualquer1">

ngStyle
<p [ngStyle]="{ fontSize: myFontSize, color: myColor }">TEST</p>

ngClass
<p [ngClass]="myClass">TEST</p>

ngIf -> aqui o componente não existe na tela qando false
<mat-form-field *ngIf="showName">

ngFor -> percorre os elementos de um array
<p *ngFor="let name of names; let i=index"> {{i}} - {{name}}</p>

ngSwitch -> switch case normal
 <section [ngSwitch]="fieldname">
	<button *ngSwitchCase="'button'" mat-raised-button color=warn>Button</button>
	<mat-checkbox *ngSwitchCase="'checkbox'">Checkbox</mat-checkbox>
	<mat-progress-bar *ngSwitchCase="'progressbar'" color="warn" mode="indeterminate"></mat-progress-bar>
</section>

ngTemplate (uso com else) -> serve para incluir um conteúdo html

<h1 *ngIf="enable else mytemplate">Enabled</h1>
<!--#variável de referencia-->
<ng-template #mytemplate>
 ...
 
ngContainer -> parecido com ngTemplate serve para incluir conteudos dentro dele
<ul>
  <ng-container *ngFor="let user of users">
	<li *ngIf="user.role==='admin'">
	  {{user.login}}
	</li>
  </ng-container>
</ul>

<ng-content></ng-content> -> inclui conteudo dentro do componente filho

--- Passando parametros para componente filho
import { Input } from '@angular/core';
@Input() title: string;


<comp title="blablabla">

--- retornando uma ação para o componente pai
import { Output, EventEmitter } from '@angular/core';
@Output() plusOne = new EventEmitter<any>();
plusOneClick() {
  this.plusOne.emit();
}

<comp (plusOne)="metodoDoPai()">

---- Binding de componentes de tela 

// pega o componente pelo nome #stopwatch
@ViewChild("stopwatch", {static: true})
private myTimer: TimerComponent;

// pega o primeiro componente de tela do tipo encontrado
@ViewChild(TimerComponent, {static: false})
private myTimer: TimerComponent;

// pegando um component <p>
@ViewChild('myP', {static: false})
private myP: ElementRef;

// chamado apos todas as referencias de variaveis estarem prontas
ngAfterViewInit() {
  console.log(this.myP);
}


---- detectando mudanças
// indico a interface OnChanges para implementa-la
export class NameChangeComponent implements OnInit, OnChanges {

// implemento o metodo. Aqui é possível capturar as mudanças nas propriedades
ngOnChanges(changes: {[propKey: string]: SimpleChange}): void {
    console.log(changes);
    // verifico se existe a propriedade name q é o atributo que quero capturar a mudança
    if (changes.hasOwnProperty('name')) {
      this.nameBefore = changes['name'].previousValue;
    }
  }

-- capturando mudanças no @Input
  // seto um metodo no @Input(), no lugar de uma variavel
  @Input()
  // quando uso o set o name vira uma propriedade, essa é uma funçãodo TS
  set name(name: string) {
    this._name = 'Your name: ' + (name.toUpperCase().trim() || '<name empty>');
  }

  get name(): string {
    return this._name;
  }




90 -> 


49,99 7,5g - face instagram e twiter, zap sem limite

com portabilidade ganha 

39,99 - 6G - zap sem limite  550minutos




